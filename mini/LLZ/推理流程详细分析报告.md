# model_data.tflite æ¨ç†æµç¨‹è¯¦ç»†åˆ†ææŠ¥å‘Š

> **åŸºäº**: `main.cc` å®é™…æ¨ç†ä»£ç   
> **æ¨¡å‹**: MinLSTM_XS_S20K32 (stateful)  
> **å¹³å°**: ESP32-S3 + TensorFlow Lite Micro  
> **åˆ†ææ—¥æœŸ**: 2026å¹´2æœˆ12æ—¥

---

## ğŸ“‹ ç›®å½•

1. [æ¨¡å‹åŸºæœ¬ä¿¡æ¯](#1-æ¨¡å‹åŸºæœ¬ä¿¡æ¯)
2. [ä¸‰ç§æ¨ç†æ¨¡å¼](#2-ä¸‰ç§æ¨ç†æ¨¡å¼)
3. [æµå¼æ¨ç†æ ¸å¿ƒæµç¨‹](#3-æµå¼æ¨ç†æ ¸å¿ƒæµç¨‹)
4. [å†…å­˜ç®¡ç†ç­–ç•¥](#4-å†…å­˜ç®¡ç†ç­–ç•¥)
5. [å…³é”®æŠ€æœ¯ç»†èŠ‚](#5-å…³é”®æŠ€æœ¯ç»†èŠ‚)
6. [æ€§èƒ½ä¼˜åŒ–æŠ€å·§](#6-æ€§èƒ½ä¼˜åŒ–æŠ€å·§)

---

## 1. æ¨¡å‹åŸºæœ¬ä¿¡æ¯

### 1.1 æ¨¡å‹æ ‡è¯†

```cpp
#define CURRENT_MODEL_DATA create_model_MinLSTM_XS_S20K32_stateful_tflite
```

- **æ¨¡å‹åç§°**: MinLSTM_XS_S20K32
- **ç±»å‹**: Stateful RNN (æœ‰çŠ¶æ€å¾ªç¯ç¥ç»ç½‘ç»œ)
- **å¤§å°**: ~270 KB
- **ç²¾åº¦**: Float32

### 1.2 è¾“å…¥è¾“å‡ºè§„æ ¼ï¼ˆä»ä»£ç æ¨æ–­ï¼‰

#### è¾“å…¥1: EMGæ•°æ®
```cpp
// ä» main.cc è¡Œ398æ£€æµ‹ç»“æœ
input_data->dims: [1, 16, 32]
```
- **batch**: 1
- **channels**: 16 (16é€šé“EMG)
- **time_steps**: 32 (32ä¸ªé‡‡æ ·ç‚¹)
- **å¸ƒå±€**: **Channel-Major** `[Batch, Channels, Time]`
- **æ•°æ®ç±»å‹**: Float32
- **å­—èŠ‚æ•°**: 1Ã—16Ã—32Ã—4 = 2048 bytes

#### è¾“å…¥2: RNNçŠ¶æ€
```cpp
input_state (è‡ªåŠ¨æ£€æµ‹)
```
- **å½¢çŠ¶**: æ¨æµ‹ `[2, 1, 32]` æˆ–ç±»ä¼¼
- **å«ä¹‰**: LSTMçš„ hidden state + cell state
- **å­—èŠ‚æ•°**: ä»£ç ä¸­åŠ¨æ€æ£€æµ‹

#### è¾“å‡º1: æ‰‹åŠ¿é¢„æµ‹
```cpp
output_pred
```
- **å½¢çŠ¶**: `[1, 9, 1]` (æ¨æµ‹)
- **å«ä¹‰**: 9ç§æ‰‹åŠ¿çš„logits
- **éœ€è¦**: Sigmoidæ¿€æ´»è½¬ä¸ºæ¦‚ç‡

#### è¾“å‡º2: æ›´æ–°çš„RNNçŠ¶æ€
```cpp
output_state
```
- é—­ç¯ä¼ é€’ç»™ä¸‹ä¸€å¸§

---

## 2. ä¸‰ç§æ¨ç†æ¨¡å¼

### 2.1 æ¨¡å¼1: Benchmark (åŸºå‡†æµ‹è¯•)

**ç›®æ ‡**: è¯„ä¼°æ¨ç†æ€§èƒ½

```cpp
const int NUM_ITERATIONS = 100;
const int STEPS_NEW = 20;      // æ¯æ¬¡æ»‘åŠ¨20ä¸ªæ–°æ ·æœ¬
const int ELEMENTS_NEW = 320;  // 20 * 16 = 320ä¸ªfloat

// æ¨¡æ‹Ÿå®æ—¶æ•°æ®æµæ¨ç†
for (int i = 0; i < NUM_ITERATIONS; ++i) {
    // 1. Ring Bufferæ›´æ–° (Channel-Major)
    for (int ch = 0; ch < channels; ch++) {
        float *ch_ptr = shadow_buffer + (ch * steps_total);
        // å·¦ç§»ä¿ç•™overlap
        memmove(ch_ptr, ch_ptr + STEPS_NEW, 
                (steps_total - STEPS_NEW) * sizeof(float));
        // åé¢è¡¥é›¶ (æ¨¡æ‹Ÿæ–°æ•°æ®)
    }
    
    // 2. åŒæ­¥åˆ°TFLiteè¾“å…¥
    memcpy(input_data->data.f, shadow_buffer, input_data->bytes);
    
    // 3. æ¨ç†
    interpreter->Invoke();
    
    // 4. çŠ¶æ€é—­ç¯
    if (input_state && output_state) {
        memcpy(input_state->data.data, 
               output_state->data.data, 
               input_state->bytes);
    }
}
```

**æ€§èƒ½æŒ‡æ ‡**:
- å¹³å‡æ¨ç†å»¶è¿Ÿ (us)
- ååé‡ (FPS)
- Arenaä½¿ç”¨ç‡

---

### 2.2 æ¨¡å¼2: Verification (éªŒè¯æ¨¡å¼)

**ç›®æ ‡**: ä¸PCç«¯PyTorchæ¨¡å‹å¯¹æ¯”ï¼ŒéªŒè¯æ•°å€¼ä¸€è‡´æ€§

#### æ•°æ®æ ¼å¼ (verif.bin)

```cpp
struct VerifHeader {
    uint32_t magic;        // 0x46524556 ("VERF")
    uint32_t num_steps;    // é¢„æµ‹æ­¥æ•° (e.g., 3978)
    uint32_t in_ch;        // è¾“å…¥é€šé“ (16)
    uint32_t out_ch;       // è¾“å‡ºé€šé“ (9)
    uint32_t raw_len;      // åŸå§‹è¾“å…¥é•¿åº¦
};

// æ–‡ä»¶å¸ƒå±€:
// [Header] [Input Data] [PC Output] [Ground Truth]
```

#### éªŒè¯æµç¨‹

```cpp
// 1. åŠ è½½éªŒè¯æ•°æ® (ä»SPIFFS)
float *file_inputs;       // åŸå§‹EMGæ•°æ®
float *file_outputs;      // PyTorchå‚è€ƒè¾“å‡º
float *file_gt_outputs;   // Ground Truthæ ‡ç­¾

// 2. åˆå§‹åŒ–Shadow Buffer (ç¬¬ä¸€ä¸ªå®Œæ•´çª—å£)
for (int ch = 0; ch < in_ch; ch++) {
    memcpy(shadow_buffer + ch*steps_total, 
           file_inputs + ch*raw_input_len, 
           steps_total * sizeof(float));
}

// 3. é€æ­¥éªŒè¯
for (int i = 0; i < num_steps; i++) {
    // A. Ring Bufferæ»‘åŠ¨
    // B. æ¨ç†
    // C. çŠ¶æ€æ›´æ–°
    // D. å¯¹æ¯”MCU vs PyTorch vs GT
    
    // è®¡ç®—æŒ‡æ ‡:
    float mcu_prob = sigmoid(output_pred->data.f[...]);
    float pc_prob = file_outputs[...];
    float gt_val = file_gt_outputs[...];
    
    // MAE: |mcu - pc|
    // æ··æ·†çŸ©é˜µ: TP/FP/FN/TN
}
```

#### éªŒè¯æŒ‡æ ‡

**ä¸‰ç§å¯¹æ¯”**:
1. **MCU vs GT**: å®é™…ç²¾åº¦ (CLERæŒ‡æ ‡)
2. **MCU vs PC**: æ•°å€¼ä¸€è‡´æ€§ (MAE)
3. **PC vs GT**: PyTorchåŸºçº¿ç²¾åº¦

**è¾“å‡ºç¤ºä¾‹**:
```
Overall (Flattened) MCU vs GT:
  CLER: 0.1234 (12.34%)
  Accuracy:  0.9456
  Precision: 0.8901
  Recall:    0.8766
  F1-Score:  0.8833
```

---

### 2.3 æ¨¡å¼3: Streaming (æµå¼æ¨ç†)

**ç›®æ ‡**: å®é™…ç”Ÿäº§ç¯å¢ƒçš„å®æ—¶æ¨ç†

#### æ ¸å¿ƒå‚æ•°

```cpp
const int kModelInputSteps = 32;   // æ¨¡å‹è¾“å…¥çª—å£
const int kUpdateStride = 20;      // æ¯æ¬¡æ»‘åŠ¨çš„æ­¥é•¿
const int kHistorySteps = 12;      // é‡å å†å² (32-20)
const int kChannels = 16;
```

**å…³é”®ç†è§£**: 
- æ¨¡å‹éœ€è¦32ä¸ªæ—¶é—´æ­¥çš„å®Œæ•´çª—å£
- æ¯æ¬¡åªå¤„ç†20ä¸ªæ–°é‡‡æ ·ç‚¹
- ä¿ç•™12ä¸ªå†å²é‡‡æ ·ç‚¹ä½œä¸ºé‡å ä¸Šä¸‹æ–‡

---

## 3. æµå¼æ¨ç†æ ¸å¿ƒæµç¨‹

### 3.1 é›¶æ‹·è´ä¼˜åŒ–

```cpp
// ç›´æ¥åœ¨TFLiteè¾“å…¥å†…å­˜ä¸Šæ“ä½œï¼Œé¿å…é¢å¤–æ‹·è´
float* tflite_input_ptr = model_input->data.f;

// åˆå§‹åŒ–ä¸ºé›¶ (å†·å¯åŠ¨)
memset(tflite_input_ptr, 0, model_input->bytes);
```

### 3.2 å®Œæ•´æ¨ç†å¾ªç¯

```cpp
while (1) {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // æ­¥éª¤A: è¯»å–æ–°æ•°æ® (20*16 = 320 floats)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const int kBytesNewData = 20 * 16 * sizeof(float);
    float *uart_recv_f = ...;  // ä»UART/stdinè¯»å–
    
    size_t total_read = 0;
    while (total_read < kBytesNewData) {
        size_t n = fread(uart_recv_f + total_read, 1, 
                        kBytesNewData - total_read, stdin);
        if (n > 0) total_read += n;
        else taskYIELD();  // ç­‰å¾…æ•°æ®
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // æ­¥éª¤B: é›¶æ‹·è´æ»‘åŠ¨çª—å£æ›´æ–° (Channel-Majorå¸ƒå±€)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    for (int ch = 0; ch < 16; ch++) {
        // æ¯ä¸ªé€šé“ç‹¬ç«‹å¤„ç†
        float* ch_ptr = tflite_input_ptr + (ch * 32);
        
        // 1. å·¦ç§»ä¿ç•™overlap (12ä¸ªå†å²æ ·æœ¬)
        memmove(ch_ptr, ch_ptr + 20, 12 * sizeof(float));
        
        // 2. å»äº¤ç»‡æ–°æ•°æ®å¹¶è¿½åŠ åˆ°æœ«å°¾
        for (int t = 0; t < 20; t++) {
            float raw_val = uart_recv_f[t * 16 + ch];
            
            // å¯é€‰: DC-blockeræ»¤æ³¢
            float filtered = raw_val - dc_x[ch] + 0.95f * dc_y[ch];
            dc_x[ch] = raw_val;
            dc_y[ch] = filtered;
            
            ch_ptr[12 + t] = filtered;  // å†™å…¥ä½ç½®[12..31]
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // æ­¥éª¤C: æ¨ç† (æ— éœ€memcpy!)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (interpreter->Invoke() != kTfLiteOk) {
        ESP_LOGE(TAG, "Invoke failed!");
        continue;
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // æ­¥éª¤D: çŠ¶æ€é—­ç¯
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    if (input_state && output_state) {
        memcpy(input_state->data.data, 
               output_state->data.data, 
               input_state->bytes);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // æ­¥éª¤E: è¾“å‡ºç»“æœ
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // 1. Logits -> Probabilities
    float *out_ptr = output_pred->data.f;
    int out_count = output_pred->bytes / sizeof(float);
    for (int k = 0; k < out_count; k++) {
        out_ptr[k] = sigmoid(out_ptr[k]);
    }
    
    // 2. å†™å›stdout (å‘é€ç»™ä¸Šä½æœº)
    fwrite(output_pred->data.data, 1, 
           output_pred->bytes, stdout);
    fflush(stdout);
}
```

### 3.3 æ•°æ®æµç¤ºæ„å›¾

```
æ—¶é—´è½´: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’
         20æ­¥  20æ­¥  20æ­¥  20æ­¥
         â”‚    â”‚    â”‚    â”‚
å¸§0: [â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€32æ­¥çª—å£â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€]
              â†“ æ¨ç†
         è¾“å‡º[0] + State[0]

å¸§1:      [12é‡å ][â”€â”€20æ–°æ•°æ®â”€â”€]
          [â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€32æ­¥çª—å£â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€]
                   â†“ æ¨ç† (ä½¿ç”¨State[0])
              è¾“å‡º[1] + State[1]

å¸§2:           [12é‡å ][â”€â”€20æ–°æ•°æ®â”€â”€]
               [â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€32æ­¥çª—å£â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€]
                        â†“ æ¨ç† (ä½¿ç”¨State[1])
                   è¾“å‡º[2] + State[2]
```

**å…³é”®ç‚¹**:
- 32æ­¥çª—å£è¦†ç›– 16ms @ 2kHz
- æ¯20æ­¥æ»‘åŠ¨ = 10msæ›´æ–°é—´éš”
- 12æ­¥é‡å æä¾›æ—¶åºä¸Šä¸‹æ–‡

---

## 4. å†…å­˜ç®¡ç†ç­–ç•¥

### 4.1 åˆ†å±‚å†…å­˜æ¶æ„

```cpp
// ESP32-S3å†…å­˜å±‚çº§
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Internal SRAM (~370KB)              â”‚ â† æœ€å¿«ï¼Œä¼˜å…ˆä½¿ç”¨
â”‚  - Tensor Arena: 60KB               â”‚
â”‚  - æ¨¡å‹æ•°æ®: 270KB (å¦‚æœæ”¾å¾—ä¸‹)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“ Fallback
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ External PSRAM (~2MB+)              â”‚ â† è¾ƒæ…¢ï¼Œå®¹é‡å¤§
â”‚  - éªŒè¯æ•°æ®ç¼“å†²åŒº                   â”‚
â”‚  - Shadow Buffer                    â”‚
â”‚  - æ¨¡å‹æ•°æ® (å¦‚æœSRAMä¸å¤Ÿ)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 å†…å­˜åˆ†é…ä»£ç 

```cpp
// 1. åˆ†é…Tensor Arena (ä¼˜å…ˆSRAM)
tensor_arena = (uint8_t *)heap_caps_malloc(
    60 * 1024, 
    MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT
);

// Fallbackåˆ°PSRAM
if (tensor_arena == nullptr) {
    tensor_arena = (uint8_t *)heap_caps_malloc(
        60 * 1024, 
        MALLOC_CAP_SPIRAM
    );
}

// 2. æ¨¡å‹æ•°æ®æ‹·è´åˆ°RAM (åŠ é€Ÿè®¿é—®)
model_in_ram = (uint8_t *)heap_caps_malloc(
    model_size, 
    MALLOC_CAP_INTERNAL | MALLOC_CAP_8BIT
);
if (model_in_ram == nullptr) {
    // Fallbackåˆ°PSRAM
    model_in_ram = (uint8_t *)heap_caps_malloc(
        model_size, 
        MALLOC_CAP_SPIRAM
    );
}
memcpy(model_in_ram, CURRENT_MODEL_DATA, model_size);
```

### 4.3 å†…å­˜è¯Šæ–­è¾“å‡º

```
å†…å­˜çŠ¶æ€:
  å†…éƒ¨ SRAM:  å¯ç”¨ 180.5 KB / æ€»è®¡ 370.0 KB
  å¤–éƒ¨ PSRAM: å¯ç”¨ 1800.0 KB / æ€»è®¡ 2048.0 KB

æ¨¡å‹è¯Šæ–­ä¿¡æ¯:
  Arena åˆ†é…å®¹é‡:    60 KB
  Arena å®é™…ä½¿ç”¨:    45 KB
  Arena å‰©ä½™ç©ºé—´:    15 KB
```

---

## 5. å…³é”®æŠ€æœ¯ç»†èŠ‚

### 5.1 Channel-Majorå¸ƒå±€

**ä¸ºä»€ä¹ˆé‡è¦**: å½±å“Ring Bufferçš„æ›´æ–°é€»è¾‘

```cpp
// Channel-Major: [Batch=1, Channels=16, Time=32]
// å†…å­˜å¸ƒå±€:
// [ch0_t0, ch0_t1, ..., ch0_t31, ch1_t0, ch1_t1, ..., ch15_t31]

// æ¯ä¸ªé€šé“å æ®è¿ç»­çš„32ä¸ªfloat
float* ch0_ptr = input_ptr + (0 * 32);  // é€šé“0
float* ch1_ptr = input_ptr + (1 * 32);  // é€šé“1
...
```

**vs Time-Major** `[Batch, Time, Channels]`:
```cpp
// å†…å­˜å¸ƒå±€:
// [t0_ch0, t0_ch1, ..., t0_ch15, t1_ch0, ...]
```

### 5.2 DC-Blockeræ»¤æ³¢å™¨

**ç›®çš„**: ç§»é™¤ç›´æµåˆ†é‡ï¼Œé«˜é€šæ»¤æ³¢

```cpp
// ä¸€é˜¶IIRé«˜é€šæ»¤æ³¢å™¨ (æˆªæ­¢é¢‘ç‡ ~1.6Hz @ 2kHzé‡‡æ ·)
float dc_x[16] = {0};  // ä¸Šä¸€æ¬¡è¾“å…¥
float dc_y[16] = {0};  // ä¸Šä¸€æ¬¡è¾“å‡º

// ä¼ é€’å‡½æ•°: H(z) = (1 - z^-1) / (1 - 0.95*z^-1)
for (int ch = 0; ch < 16; ch++) {
    float raw = input[ch];
    float filtered = raw - dc_x[ch] + 0.95f * dc_y[ch];
    dc_x[ch] = raw;
    dc_y[ch] = filtered;
    output[ch] = filtered;
}
```

**æ³¨æ„**: å¦‚æœè®­ç»ƒæ•°æ®å·²ç»åšè¿‡é«˜é€šæ»¤æ³¢ï¼Œå¯ä»¥ç§»é™¤æ­¤æ­¥éª¤ã€‚

### 5.3 Sigmoidæ¿€æ´»

```cpp
inline float sigmoid(float x) { 
    return 1.0f / (1.0f + expf(-x)); 
}

// åº”ç”¨åˆ°è¾“å‡º
for (int k = 0; k < 9; k++) {
    float logit = output_pred->data.f[k];
    float prob = sigmoid(logit);
    // probç°åœ¨åœ¨[0, 1]èŒƒå›´
}
```

### 5.4 æ‰‹åŠ¿æ£€æµ‹é˜ˆå€¼

```cpp
const float kThreshold = 0.35f;  // å¯è°ƒ

// äºŒå€¼åŒ– (åœ¨éªŒè¯æ¨¡å¼ä¸­)
int gesture_detected = (prob > kThreshold) ? 1 : 0;
```

**å»ºè®®**: æ ¹æ®å®é™…åº”ç”¨åœºæ™¯è°ƒæ•´é˜ˆå€¼
- ç²¾ç¡®ç‡ä¼˜å…ˆ: æé«˜é˜ˆå€¼ (0.5, 0.6)
- å¬å›ç‡ä¼˜å…ˆ: é™ä½é˜ˆå€¼ (0.25, 0.3)

---

## 6. æ€§èƒ½ä¼˜åŒ–æŠ€å·§

### 6.1 å·²å®ç°çš„ä¼˜åŒ–

1. **é›¶æ‹·è´æ»‘åŠ¨çª—å£**
   - ç›´æ¥åœ¨TFLiteè¾“å…¥å†…å­˜ä¸Šmemmove
   - é¿å…Shadow Buffer â†’ TFLiteçš„æ‹·è´

2. **æ¨¡å‹é¢„åŠ è½½åˆ°RAM**
   - ä»Flashæ‹·è´åˆ°SRAM/PSRAM
   - åŠ é€Ÿæ¨¡å‹æƒé‡è®¿é—®

3. **å…³é—­IOç¼“å†²**
   ```cpp
   setvbuf(stdin, NULL, _IONBF, 0);
   setvbuf(stdout, NULL, _IONBF, 0);
   ```

4. **çœ‹é—¨ç‹—è¶…æ—¶å»¶é•¿**
   ```cpp
   esp_task_wdt_config_t twdt_config = {
       .timeout_ms = 60000,  // 60ç§’
       ...
   };
   ```

### 6.2 æ½œåœ¨ä¼˜åŒ–æ–¹å‘

#### A. é‡åŒ– (Int8)
```cpp
// å½“å‰: Float32 (4å­—èŠ‚/å…ƒç´ )
// ä¼˜åŒ–: Int8 (1å­—èŠ‚/å…ƒç´ )
//
// é¢„æœŸæå‡:
//   - æ¨¡å‹å¤§å°: 270KB â†’ ~70KB (4å€å‹ç¼©)
//   - æ¨ç†é€Ÿåº¦: 2-3å€åŠ é€Ÿ
//   - ç²¾åº¦æŸå¤±: <1% (é€šå¸¸å¯æ¥å—)
```

#### B. ç®—å­èåˆ
- Conv + ReLU èåˆ
- LayerNormå†…è”
- LSTMé—¨æ§ä¼˜åŒ–

#### C. å¹¶è¡Œå¤„ç†
```cpp
// ESP32-S3åŒæ ¸
// Core 0: EMGæ•°æ®é‡‡é›† + é¢„å¤„ç†
// Core 1: æ¨¡å‹æ¨ç† + è¾“å‡º
```

#### D. æ‰¹å¤„ç†
```cpp
// å½“å‰: batch=1, æ¯20æ­¥æ¨ç†ä¸€æ¬¡
// ä¼˜åŒ–: ç´¯ç§¯å¤šå¸§åæ‰¹é‡æ¨ç† (éœ€ä¿®æ”¹æ¨¡å‹)
```

---

## 7. è°ƒè¯•æŠ€å·§

### 7.1 å†…å­˜æ£€æŸ¥

```cpp
// æ£€æŸ¥æŒ‡é’ˆä½ç½®
bool ptr_is_in_internal_ram(void *ptr) {
    return ((uint32_t)ptr >= 0x3FC80000 && 
            (uint32_t)ptr < 0x3FD00000) ||
           ((uint32_t)ptr >= 0x40370000 && 
            (uint32_t)ptr < 0x403E0000);
}

ESP_LOGI(TAG, "Model at %p (%s)", 
         model_in_ram,
         ptr_is_in_internal_ram(model_in_ram) 
             ? "SRAM" : "PSRAM");
```

### 7.2 å¼ é‡å½¢çŠ¶æ£€æŸ¥

```cpp
ESP_LOGI(TAG, "Input Tensor Shape:");
for (int i = 0; i < input->dims->size; i++) {
    ESP_LOGI(TAG, "  dim[%d] = %d", 
             i, input->dims->data[i]);
}
```

### 7.3 æ•°å€¼èŒƒå›´ç›‘æ§

```cpp
// æ£€æŸ¥æ˜¯å¦æœ‰NaN/Inf
float *data = input->data.f;
for (int i = 0; i < input->bytes/4; i++) {
    if (isnan(data[i]) || isinf(data[i])) {
        ESP_LOGE(TAG, "Invalid value at [%d]: %f", i, data[i]);
    }
}
```

---

## 8. å®Œæ•´æ•°æ®æµæ€»ç»“

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å®æ—¶EMGæ•°æ®é‡‡é›†                           â”‚
â”‚              16é€šé“ @ 2000Hz (0.5ms/sample)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â†“
         ç´¯ç§¯20ä¸ªæ ·æœ¬ (10ms)
                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Ring Bufferæ»‘åŠ¨çª—å£æ›´æ–°                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚   â”‚ [12å†å²][â”€â”€20æ–°æ•°æ®â”€â”€] = 32æ­¥çª—å£  â”‚                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚               Channel-Majorå¸ƒå±€                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            å¯é€‰: DC-Blockeré«˜é€šæ»¤æ³¢                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              TFLiteæ¨ç† (é›¶æ‹·è´)                            â”‚
â”‚         Input: [1,16,32] + State[t-1]                       â”‚
â”‚                    â†“                                         â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚         â”‚  Reinhardå‹ç¼©        â”‚                            â”‚
â”‚         â”‚  Conv1Dç‰¹å¾æå–      â”‚                            â”‚
â”‚         â”‚  LayerNormå½’ä¸€åŒ–     â”‚                            â”‚
â”‚         â”‚  LSTMæ—¶åºå»ºæ¨¡        â”‚                            â”‚
â”‚         â”‚  å…¨è¿æ¥æŠ•å½±          â”‚                            â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                    â†“                                         â”‚
â”‚         Output: Logits[1,9,1] + State[t]                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â†“
         Sigmoid(logits) â†’ æ¦‚ç‡
                  â†“
         é˜ˆå€¼åˆ¤æ–­ (0.35)
                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              æ‰‹åŠ¿è¯†åˆ«ç»“æœè¾“å‡º                                â”‚
â”‚  [G0:index_press, G1:index_release, ..., G8:thumb_up]      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â†“
         å‘é€ç»™ä¸Šä½æœº (UART/stdout)
```

**å…³é”®æ—¶åº**:
- é‡‡æ ·å‘¨æœŸ: 0.5ms (2000Hz)
- ç´¯ç§¯å‘¨æœŸ: 10ms (20 samples)
- æ¨ç†å»¶è¿Ÿ: ~20-50ms (å–å†³äºç¡¬ä»¶)
- æ€»å»¶è¿Ÿ: <70ms (å®æ—¶æ€§è‰¯å¥½)

---

## é™„å½•A: å…³é”®ä»£ç ç‰‡æ®µç´¢å¼•

| åŠŸèƒ½ | è¡Œå· (main.cc) | è¯´æ˜ |
|------|---------------|------|
| æ¨¡å‹å®šä¹‰ | 18 | `#include "model_data.h"` |
| Sigmoidå‡½æ•° | 21 | `inline float sigmoid(float x)` |
| Arenaåˆ†é… | 40-44 | `kTensorArenaSize = 60*1024` |
| æ¨¡å‹åŠ è½½ | 152-158 | `tflite::GetModel(model_in_ram)` |
| ç®—å­æ³¨å†Œ | 164-201 | `MicroMutableOpResolver<64>` |
| Benchmarkå¾ªç¯ | 374-439 | Ring Buffer + Invoke |
| Verificationæ¨¡å¼ | 471-750 | SPIFFS + MAEè®¡ç®— |
| Streamingæ¨¡å¼ | 902-987 | é›¶æ‹·è´å®æ—¶æ¨ç† |

---

## é™„å½•B: æ¨¡å‹æ–‡ä»¶ç»“æ„

```
LLZ/
â”œâ”€â”€ model_data.h               # æ¨¡å‹æƒé‡å¤´æ–‡ä»¶
â”œâ”€â”€ model_data.tflite          # TFLiteæ¨¡å‹æ–‡ä»¶
â”œâ”€â”€ model_data.tflite.png      # Netronå¯è§†åŒ–å›¾
â”œâ”€â”€ model_data.tflite.report.json  # è¯¦ç»†åˆ†ææŠ¥å‘Š
â”œâ”€â”€ main.cc                    # ä¸»æ¨ç†ç¨‹åº â­
â””â”€â”€ validate_tflite_discrete_gestures.py  # PCç«¯éªŒè¯è„šæœ¬
```

---

## é™„å½•C: ä¸è®­ç»ƒæ¨¡å‹çš„å·®å¼‚

**é‡è¦**: è¿™ä¸ªæ¨¡å‹ä¸ `mytrain.py` **ä¸æ˜¯åŒä¸€ä¸ªæ¨¡å‹**ï¼

| é¡¹ç›® | mytrain.py | model_data.tflite |
|------|-----------|-------------------|
| æ¨¡å‹åç§° | æœªçŸ¥å¤§æ¨¡å‹ | MinLSTM_XS_S20K32 |
| è¾“å…¥çª—å£ | 16000 (8ç§’) | 32 (16ms) |
| è¾“å…¥å¸ƒå±€ | Time-Major | Channel-Major |
| LSTMç±»å‹ | æ ‡å‡†LSTM | MinLSTM (è½»é‡åŒ–) |
| æ¨ç†æ–¹å¼ | æ‰¹å¤„ç† | é€å¸§æœ‰çŠ¶æ€ |
| ç›®æ ‡è®¾å¤‡ | GPU/CPU | ESP32-S3 MCU |

---

**åˆ†æå®Œæˆæ—¶é—´**: 2026å¹´2æœˆ12æ—¥  
**ç‰ˆæœ¬**: v2.0 (åŸºäºmain.ccå®é™…ä»£ç )
